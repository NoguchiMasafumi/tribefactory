<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flat Polygon Human in 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        .ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-family: sans-serif;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            user-select: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div class="ui">
        <h3>Flat Polygon Human (3D Space)</h3>
        <p>è¦‹ãŸç›®ã¯å¹³é¢ã€ç©ºé–“ã¯3D<br>
        ğŸ–±ï¸ Drag: Rotate Camera<br>
        ğŸ” Wheel: Zoom<br>
        ğŸ‘† Double Click: Reset</p>
    </div>

<script>
    // --- 1. åŸºæœ¬ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e); 
    // scene.fog = new THREE.Fog(0x1a1a2e, 20, 100);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 20); 

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // å¹³é¢ãªã®ã§ãƒ©ã‚¤ãƒˆã¯ä¸è¦ï¼ˆç™ºå…‰ã™ã‚‹ã‚ˆã†ã«è¦‹ã›ã‚‹ãŸã‚BasicMaterialã‚’ä½¿ç”¨ï¼‰ã§ã™ãŒã€
    // ç©ºé–“ã®å¥¥è¡Œãã‚’æ„Ÿã˜ã‚‹ãŸã‚ã«ã‚°ãƒªãƒƒãƒ‰ã¯å°‘ã—æš—ãæç”»
    const gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x111111);
    scene.add(gridHelper);

    // --- 2. å¹³é¢ãƒãƒªã‚´ãƒ³ä½œæˆé–¢æ•° ---
    
    // ãƒãƒ†ãƒªã‚¢ãƒ«ï¼šå½±ã®å½±éŸ¿ã‚’å—ã‘ãªã„ã€Œç™ºå…‰è‰²ã€ã®ã‚ˆã†ãªè¨­å®š (MeshBasicMaterial)
    // side: THREE.DoubleSide â†’ è£å´ã‹ã‚‰è¦‹ã¦ã‚‚æ¶ˆãˆãªã„ã‚ˆã†ã«ã™ã‚‹
    const matBody = new THREE.MeshBasicMaterial({ color: 0x00f2ff, side: THREE.DoubleSide });
    const matLimb = new THREE.MeshBasicMaterial({ color: 0x2196f3, side: THREE.DoubleSide });
    const matHead = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
    
    // ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ç”¨ï¼ˆç™½æ ï¼‰
    const matLine = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 });

    function createFlatPoly(width, length, material, type = 'triangle') {
        const shape = new THREE.Shape();
        
        // 2Dã®æç”»ãƒ­ã‚¸ãƒƒã‚¯ã‚’ãã®ã¾ã¾Three.jsã®Shapeã§å†ç¾
        // åŸç‚¹(0,0)ãŒå›è»¢è»¸ã«ãªã‚Šã¾ã™
        shape.moveTo(0, 0); 
        
        if (type === 'triangle') {
            shape.lineTo(-width / 2, length);
            shape.lineTo(width / 2, length);
        } else if (type === 'diamond') {
            shape.moveTo(0, -length/2); // å°‘ã—ä¸‹ã«ãšã‚‰ã™
            shape.lineTo(-width/2, length/2);
            shape.lineTo(0, length * 1.2);
            shape.lineTo(width/2, length/2);
            shape.lineTo(0, -length/2);
        }
        shape.lineTo(0, 0); // é–‰ã˜ã‚‹

        // å½¢çŠ¶ã‹ã‚‰ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’ä½œæˆ
        const geometry = new THREE.ShapeGeometry(shape);
        const mesh = new THREE.Mesh(geometry, material);

        // æ ç·šï¼ˆãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰ã‚’è¿½åŠ 
        const edges = new THREE.EdgesGeometry(geometry);
        const line = new THREE.LineSegments(edges, matLine);
        mesh.add(line);

        // ã‚°ãƒ«ãƒ¼ãƒ—ï¼ˆé–¢ç¯€ï¼‰ã«å…¥ã‚Œã¦è¿”ã™
        const joint = new THREE.Group();
        joint.add(mesh);

        // Zãƒ•ã‚¡ã‚¤ãƒ†ã‚£ãƒ³ã‚°ï¼ˆé‡ãªã‚Šãƒãƒ©ã¤ãï¼‰é˜²æ­¢ã®ãŸã‚ã€ã”ãã‚ãšã‹ã«Zã‚’ãšã‚‰ã™
        mesh.position.z = 0.01; 

        return { joint, mesh };
    }

    // --- 3. äººå½¢çµ„ã¿ç«‹ã¦ ---
    // â€» Three.jsã®å˜ä½ç³»ã«åˆã‚ã›ã¦ã‚µã‚¤ã‚ºã‚’èª¿æ•´ã—ã¦ã„ã¾ã™ï¼ˆå…ƒã®ç´„1/10ï¼‰

    const hipsGroup = new THREE.Group();
    hipsGroup.position.y = 11; // é«˜ã•
    scene.add(hipsGroup);

    // è…° (Hips)
    const hips = createFlatPoly(1.5, 1.0, matBody, 'triangle');
    // å…ƒã®Canvasã¯YãŒä¸‹å‘ãæ­£ã§ã—ãŸãŒã€3Dã¯YãŒä¸Šå‘ãæ­£ãªã®ã§ã€
    // createFlatPolyã¯ã€Œä¸Šã€ã«å‘ã‹ã£ã¦ä¸‰è§’å½¢ã‚’ä½œã‚‹ä»•æ§˜ã«ã—ã¦ã„ã¾ã™ã€‚
    // è…°ã¯é€†ä¸‰è§’å½¢ã«ã—ãŸã„ã®ã§å›è»¢
    hips.joint.rotation.z = Math.PI; 
    hipsGroup.add(hips.joint);

    // èƒ´ä½“ (Torso)
    const torso = createFlatPoly(1.8, 2.8, matBody, 'triangle');
    torso.joint.position.y = 0.2; // è…°ã¨ã®ã¤ãªãç›®
    torso.joint.rotation.z = Math.PI; // ã“ã‚Œã‚‚é€†ä¸‰è§’å½¢ï¼ˆä¸Šå‘ãã«ã™ã‚‹ãŸã‚åè»¢ã®åè»¢...ã§ã¯ãªãä¸Šå‘ãã®ã¾ã¾ä½¿ã†ï¼‰
    // ...ã‚ã€å…ƒã®ã‚³ãƒ¼ãƒ‰ã¯ã€Œä¸‹å‘ãä¸‰è§’å½¢ã€ã‚’æã„ã¦scale(1, -1)ã—ã¦ã¾ã—ãŸã­ã€‚
    // ã“ã“ã§ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«ã€Œä¸Šå‘ãä¸‰è§’å½¢ã€ã¨ã—ã¦æ‰±ã„ã¾ã™ã€‚
    torso.joint.rotation.z = 0; // ä¸Šå‘ã
    hipsGroup.add(torso.joint);

    // é¦–
    const neck = createFlatPoly(0.4, 0.5, matBody, 'triangle');
    neck.joint.position.y = 2.8; // èƒ´ä½“ã®ä¸Š
    torso.joint.add(neck.joint);

    // é ­
    const head = createFlatPoly(1.0, 1.2, matHead, 'diamond');
    head.joint.position.y = 0.5;
    neck.joint.add(head.joint);


    // è¶³ã‚’ä½œã‚‹é–¢æ•°
    function createLeg(isRight) {
        const side = isRight ? 1 : -1;
        
        // å¤ªã‚‚ã‚‚
        const legTop = createFlatPoly(0.8, 2.2, matLimb, 'triangle');
        legTop.joint.position.x = 0.5 * side;
        legTop.joint.position.y = 0.2; // è…°ã®ä½ç½®
        // ä¸‹ã«å‚ã‚‰ã™ãŸã‚ã«å›è»¢
        legTop.joint.rotation.z = Math.PI; 
        hipsGroup.add(legTop.joint);

        // ã™ã­
        const legBottom = createFlatPoly(0.6, 2.2, matLimb, 'triangle');
        legBottom.joint.position.y = 2.2; // å¤ªã‚‚ã‚‚ã®å…ˆç«¯ï¼ˆåè»¢ã—ã¦ã‚‹ã®ã§Yãƒ—ãƒ©ã‚¹æ–¹å‘ãŒå…ˆç«¯ï¼‰
        legTop.joint.add(legBottom.joint);

        // è¶³å…ˆ (æ¨ªå‘ãä¸‰è§’å½¢)
        const foot = createFlatPoly(0.8, 1.0, matLimb, 'triangle');
        foot.joint.position.y = 2.2;
        foot.joint.scale.set(1, 0.5, 1); // æ½°ã™
        foot.joint.rotation.z = -Math.PI / 2; // æ¨ªã«å‘ã‘ã‚‹
        legBottom.joint.add(foot.joint);

        return { top: legTop.joint, bottom: legBottom.joint };
    }

    const rightLeg = createLeg(true);
    const leftLeg = createLeg(false);


    // è…•ã‚’ä½œã‚‹é–¢æ•°
    function createArm(isRight) {
        const side = isRight ? 1 : -1;

        // ä¸Šè…•
        const armTop = createFlatPoly(0.5, 2.0, matLimb, 'triangle');
        armTop.joint.position.set(0.9 * side, 2.5, 0); // è‚©ã®ä½ç½®
        torso.joint.add(armTop.joint);

        // å‰è…•
        const armBottom = createFlatPoly(0.4, 1.8, matLimb, 'triangle');
        armBottom.joint.position.y = 2.0; 
        armTop.joint.add(armBottom.joint);

        // æ‰‹
        const hand = createFlatPoly(0.3, 0.5, matLimb, 'triangle');
        hand.joint.position.y = 1.8;
        armBottom.joint.add(hand.joint);

        // åˆæœŸè§’åº¦ï¼ˆä¸‹ã‚ã™ï¼‰
        // armTopã¯åˆæœŸçŠ¶æ…‹ã§ä¸Š(Y+)ã‚’å‘ã„ã¦ä½œã‚‰ã‚Œã¦ã„ã‚‹ã®ã§ã€
        // PI(180åº¦)å›è»¢ã•ã›ã¦ä¸‹ã«å‘ã‘ã‚‹
        const initialRot = Math.PI + (isRight ? -0.1 : 0.1);
        armTop.joint.rotation.z = initialRot;

        return { top: armTop.joint, bottom: armBottom.joint };
    }

    const rightArm = createArm(true);
    const leftArm = createArm(false);


    // --- 4. ã‚«ãƒ¡ãƒ©æ“ä½œ ---
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let cameraAngleX = 0; 
    let cameraAngleY = 0.2; 
    let cameraRadius = 25; 

    window.addEventListener('mousedown', () => isDragging = true);
    window.addEventListener('mouseup', () => isDragging = false);
    
    window.addEventListener('mousemove', (e) => {
        if (isDragging) {
            const deltaMove = {
                x: e.offsetX - previousMousePosition.x,
                y: e.offsetY - previousMousePosition.y
            };
            cameraAngleX -= deltaMove.x * 0.01;
            cameraAngleY -= deltaMove.y * 0.01;
            cameraAngleY = Math.max(-1.5, Math.min(1.5, cameraAngleY));
        }
        previousMousePosition = { x: e.offsetX, y: e.offsetY };
    });

    window.addEventListener('wheel', (e) => {
        cameraRadius += e.deltaY * 0.05;
        cameraRadius = Math.max(5, Math.min(50, cameraRadius));
    });

    window.addEventListener('dblclick', () => {
        cameraAngleX = 0; cameraAngleY = 0.2; cameraRadius = 25;
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- 5. ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ ---
    let time = 0;

    function animate() {
        requestAnimationFrame(animate);
        time += 0.05;

        // ã‚«ãƒ¡ãƒ©æ›´æ–°
        camera.position.x = cameraRadius * Math.sin(cameraAngleX) * Math.cos(cameraAngleY);
        camera.position.y = cameraRadius * Math.sin(cameraAngleY) + 11; 
        camera.position.z = cameraRadius * Math.cos(cameraAngleX) * Math.cos(cameraAngleY);
        camera.lookAt(0, 11, 0); 

        // ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ (2Dç‰ˆã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’å†ç¾)
        const breath = Math.sin(time) * 0.2;
        hipsGroup.position.y = 11 + breath;
        
        // ä½“ã®ã²ã­ã‚Šã‚’å°‘ã—å…¥ã‚Œã‚‹ï¼ˆ3Dç©ºé–“ãªã‚‰ã§ã¯ï¼‰
        hipsGroup.rotation.y = Math.sin(time * 0.3) * 0.1;

        // è¶³
        rightLeg.top.rotation.z = Math.PI + Math.sin(time) * 0.5;
        rightLeg.bottom.rotation.z = Math.abs(Math.cos(time)) * 0.5; // è†

        leftLeg.top.rotation.z = Math.PI + Math.sin(time + Math.PI) * 0.5;
        leftLeg.bottom.rotation.z = Math.abs(Math.cos(time + Math.PI)) * 0.5;

        // è…• (å…ƒã®ãƒãƒªã‚´ãƒ³Humanã¨åŒã˜ãä¸‰è§’å½¢ã‚’ã¤ãªã)
        const rightBase = Math.PI - 0.2;
        rightArm.top.rotation.z = rightBase + Math.sin(time * 0.8) * 0.1;
        rightArm.bottom.rotation.z = 0.1;

        const leftBase = Math.PI + 0.2;
        leftArm.top.rotation.z = leftBase + Math.sin(time * 0.8 + 1) * 0.1;
        leftArm.bottom.rotation.z = -0.1;

        // é ­
        neck.joint.rotation.z = Math.sin(time * 1.2) * 0.05;

        renderer.render(scene, camera);
    }

    animate();
</script>
</body>
</html>