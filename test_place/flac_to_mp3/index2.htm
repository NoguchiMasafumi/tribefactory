<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FLAC to MP3 Converter with RMS Normalize</title>
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            max-width: 600px;
            margin: 2rem auto;
            padding: 0 1rem;
            line-height: 1.6;
        }
        .container {
            border: 1px solid #ccc;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        h1 { margin-top: 0; }
        .input-group { margin-bottom: 1.5rem; }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #status { margin-top: 1rem; font-weight: bold; color: #555; }
        #downloadLink {
            display: block;
            margin-top: 1rem;
            color: #28a745;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>FLAC to MP3 変換 (平均音量統一)</h1>
    <p>目標RMS音量: **0.89** に揃えます。<br>元の音量を測定し、変換時に自動でゲイン調整を行います。</p>
    
    <div class="input-group">
        <input type="file" id="fileInput" accept=".flac">
    </div>

    <button id="convertBtn" onclick="convertAudio()">変換開始</button>

    <div id="status"></div>
    <a id="downloadLink" href="#" style="display:none;">ダウンロード MP3</a>
</div>

<script>
    // 目標の平均音量 (0.89 を RMS ターゲットとして使用)
    const TARGET_RMS_VOLUME = 0.89; 

    /**
     * RMS (平均音量) を測定し、目標RMSに達するためのゲイン乗数を計算します。
     * @param {AudioBuffer} audioBuffer デコードされた音声データ
     * @returns {number} 全体に適用すべきゲイン乗数 (K)
     */
    function calculateRMSGain(audioBuffer) {
        let sumOfSquares = 0;
        let totalSamples = 0;
        const channels = audioBuffer.numberOfChannels;

        // 全てのチャンネルのサンプルの二乗の和を求める
        for (let channel = 0; channel < channels; channel++) {
            const data = audioBuffer.getChannelData(channel);
            totalSamples += data.length;
            for (let i = 0; i < data.length; i++) {
                sumOfSquares += data[i] * data[i];
            }
        }
        
        // RMS (Root Mean Square: 実効値) を計算
        const actualRMS = Math.sqrt(sumOfSquares / totalSamples);

        if (actualRMS === 0 || totalSamples === 0) {
            console.log("警告: 音声データが見つからないか、無音です。");
            return 1.0; 
        }

        // 目標RMSが実際のRMSの何倍かを計算 = 必要なゲイン
        const gainMultiplier = TARGET_RMS_VOLUME / actualRMS;

        // ★クリッピング保護: 計算されたゲインを適用した結果、ピークが 1.0 を超えないか確認
        let maxPeak = 0;
        for (let channel = 0; channel < channels; channel++) {
             const data = audioBuffer.getChannelData(channel);
             for (let i = 0; i < data.length; i++) {
                 maxPeak = Math.max(maxPeak, Math.abs(data[i]));
             }
        }
        const peakAfterGain = maxPeak * gainMultiplier;
        
        // もしピークが 1.0 を超える場合は、音割れ（クリッピング）を防ぐためにゲインを下げる
        const finalGain = (peakAfterGain > 1.0) ? (1.0 / maxPeak) : gainMultiplier;

        console.log(`実測RMS: ${actualRMS.toFixed(4)}`);
        console.log(`目標RMS: ${TARGET_RMS_VOLUME.toFixed(4)}`);
        console.log(`初期計算ゲイン: ${gainMultiplier.toFixed(4)}`);
        console.log(`最終適用ゲイン (クリッピング保護): ${finalGain.toFixed(4)}`);

        return finalGain;
    }


    async function convertAudio() {
        const fileInput = document.getElementById('fileInput');
        const status = document.getElementById('status');
        const downloadLink = document.getElementById('downloadLink');
        const convertBtn = document.getElementById('convertBtn');

        if (fileInput.files.length === 0) {
            alert('ファイルを選択してください。');
            return;
        }

        const file = fileInput.files[0];
        
        status.textContent = 'ファイルを読み込み中...';
        downloadLink.style.display = 'none';
        convertBtn.disabled = true;

        try {
            const arrayBuffer = await file.arrayBuffer();
            status.textContent = 'デコード中 (FLACを展開)...';
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

            // ★ 1. RMS測定とゲイン計算
            status.textContent = '音量 (RMS) 測定中...';
            const calculatedGain = calculateRMSGain(audioBuffer);
            
            status.textContent = `平均音量を ${TARGET_RMS_VOLUME.toFixed(4)} に統一中 (適用ゲイン: ${calculatedGain.toFixed(4)})。エンコード中...`;
            
            await new Promise(resolve => setTimeout(resolve, 100));

            // ★ 2. 計算されたゲイン値をエンコーダーに渡す
            const mp3Blob = encodeToMp3(audioBuffer, calculatedGain); 

            // 4. ダウンロードリンクの作成
            const url = URL.createObjectURL(mp3Blob);
            downloadLink.href = url;
            downloadLink.download = file.name.replace(/\.[^/.]+$/, "") + ".mp3";
            downloadLink.style.display = 'block';
            downloadLink.textContent = 'MP3をダウンロード (' + (mp3Blob.size / 1024 / 1024).toFixed(2) + ' MB)';
            status.textContent = '変換完了！';

        } catch (e) {
            console.error(e);
            status.textContent = 'エラーが発生しました: ' + e.message;
        } finally {
            convertBtn.disabled = false;
        }
    }

    // ゲイン値 (gain) を引数に追加
    function encodeToMp3(audioBuffer, gain) { 
        const channels = audioBuffer.numberOfChannels;
        const sampleRate = audioBuffer.sampleRate;
        const kbps = 128; // MP3のビットレート

        const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, kbps);
        const mp3Data = [];

        const left = audioBuffer.getChannelData(0);
        const right = channels > 1 ? audioBuffer.getChannelData(1) : left;

        const sampleBlockSize = 1152;
        
        for (let i = 0; i < left.length; i += sampleBlockSize) {
            const leftChunk = left.subarray(i, i + sampleBlockSize);
            const rightChunk = right.subarray(i, i + sampleBlockSize);
            
            // Float32 -> Int16 変換 (ゲインを適用)
            const leftInt16 = float32ToInt16(leftChunk, gain); 
            const rightInt16 = channels > 1 ? float32ToInt16(rightChunk, gain) : undefined;

            let mp3buf;
            if (channels === 1) {
                mp3buf = mp3encoder.encodeBuffer(leftInt16);
            } else {
                mp3buf = mp3encoder.encodeBuffer(leftInt16, rightInt16);
            }

            if (mp3buf.length > 0) {
                mp3Data.push(mp3buf);
            }
        }

        const mp3buf = mp3encoder.flush();
        if (mp3buf.length > 0) {
            mp3Data.push(mp3buf);
        }

        return new Blob(mp3Data, { type: 'audio/mp3' });
    }

    // ゲイン値 (gain) を引数に追加し、適用
    function float32ToInt16(float32Array, gain) {
        const int16Array = new Int16Array(float32Array.length);
        for (let i = 0; i < float32Array.length; i++) {
            let s = float32Array[i];

            // ★ ゲインを適用
            s *= gain; 
            
            // クランピング（範囲外の値を丸める）処理
            s = Math.max(-1, Math.min(1, s));

            // 変換処理 (Float32 -> Int16)
            s = s < 0 ? s * 0x8000 : s * 0x7FFF;
            int16Array[i] = s;
        }
        return int16Array;
    }
</script>

</body>
</html>
